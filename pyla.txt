Python Logic Analyzer


Entry: Basic tools
Date: Thu Feb 27 23:34:00 CET 2014

- pyside + opengl
- inner loop in c++
- swig for python interface
- cmake for windows/linux/OSX compilation


Entry: Basic idea
Date: Thu Feb 27 23:40:39 CET 2014

- fast video update "scope like"
- point & shoot triggering
- data logger window (serial, spi, i2c)


 
Entry: GNU Radio
Date: Fri Feb 28 11:54:51 CET 2014

If this is going to be DAG of byte stream processors, it might be good
to not make it too incompatible to gnu radio processors.


Entry: Saleae Logic callbacks
Date: Fri Feb 28 13:40:08 CET 2014

SL API uses a callback.  This is a little inconvenient as it requires
calling python from C++, or needs multiple threads with a buffer to
decouple the source and sink.

Let's go for the buffered approach.  This can then be memory backed or
file backed.


Entry: Calling python from C++ with swig
Date: Fri Feb 28 16:47:22 CET 2014

Reason: cross-platform windows / pthread multi-threading without
including boost on the C++ side.

Saleae uses multithreaded callbacks.

Pff... it's probably easier to use boost.

http://stackoverflow.com/questions/12392703/what-is-the-cleanest-way-to-call-a-python-function-from-c-with-a-swig-wrapped



Entry: Use Boost.Python instead of SWIG?
Date: Fri Feb 28 16:55:28 CET 2014

https://dev.lsstcorp.org/trac/wiki/SwigVsBoostPython



Entry: Push architecutre?
Date: Fri Feb 28 18:19:39 CET 2014

It's going to feel much more natural from the device APIs to use a
push architecture.  Allow the data source to push data into a
processor network, and use mutexed polling on the result.

Or does it really not matter?

From the language side (functions), pull is more natural.

Let's continue with pull, and remove the read_sync() method.
Convention is that each read will poll its chain.


EDIT: Sort of works, but buffer management is going to be
interesting...


Entry: Memory management
Date: Fri Feb 28 21:42:14 CET 2014

Some ideas:

- combination of push/pull would be nice: 

  - push allows the large data reduction to happen strictly, so
    buffers do not grow too large

  - pull is easier to code

  - a linear processing chain can be buffered at an arbitrary place in
    the chain.

  - a dag can be transformed into a a chain if ordering is allowed

  - "fanout" is useful (i.e. obsering a multiple uarts / spi on a
    single bus).  what about "merge" after "fanout"?

